import java.math.BigInteger;
import edu.rit.pj2.Task;

/* * 
 * Class GoldbachSeq is a sequential program that calculates the prime factors of all even Numbers in a given range.
 * (i.e. Verifying Goldbach's Conjecture for all even integers in a given range.)
 * The program takes two command line arguments which are the lower-bound and upper-bound of the range.
 * 
 * The program finds i = p + q(i is an even number and p and q are its prime factors.)
 * For every iteration the program attempts to find the smallest p.
 * Finally, the program prints i = p + q such that p is the largest among all the numbers evaluated.
 * If more than one integer i evaluates the same p,we consider the maximum integer(i).
 * 
 * Usage: java pj2 GoldbachSeq <lb> <ub>
 * 
 * @author:Salil Rajadhyaksha
 * @version:20-Sept-2015.
 *  
 */
public class GoldbachSeq extends Task {

	//lower bound and Upper bound variables.
	BigInteger lb;
	BigInteger ub;

	/*
	 * main method of the program.
	 * Execution of the entire program is carried out in this method.
	 * @param: args[0]:Lower bound of the range.
	 * 		   args[1]:Upper bound of the range.
	 * @exception:NumberFormatException:Occurs if the lb or ub are not numbers.Handled in the program using Catch Block.s
	 */
	@Override
	public void main(String[] args) throws Exception {

		//check if correct number of arguments have been provided.
		if(args.length<2)
		{
			System.out.println("Invalid number of arguments.Number of arguments needed 2.");
			return;
		}
		//checks if the arguments contain any other characters other than numbers.
		try
		{
			lb=new BigInteger(args[0]);
			ub=new BigInteger(args[1]);
		}
		catch(NumberFormatException e)
		{
			System.out.println("The application expects numbers as commanad line arguments");
			return;
		}

		//Check if the lower bound is greater than 2.
		if(lb.compareTo(new BigInteger("2"))<=0)
		{
			System.out.println("Lower Bound should be an even integer greater than 2.");
			return;
		}


		//function call to check if the lowerbound and upperbound are Even.
		boolean isLbEven=checkisEven(lb);
		boolean isUbEven=checkisEven(ub);


		if(isLbEven==false)
		{
			System.out.println("LowerBound should be even");
			return;
		}


		if(isUbEven==false)
		{
			System.out.println("Upperbound should be even");
			return;
		}

		//checking if upper bound is greater than lower bound.
		if(lb.compareTo(ub)==1)
		{
			System.out.println("Invalid arguments argument:1 should be greater than or equal to argument:0");
			return;
		}
		//range of Integers
		Integer diff=ub.subtract(lb).intValue();
		//variables to store the maximum values of i,p and q.
		GoldbachVbl globalMax=new GoldbachVbl(lb,new BigInteger("2"),lb.subtract(new BigInteger("2")));
		//variables that will hold the integers for each iteration.
		BigInteger i;
		BigInteger p;
		BigInteger q;
 
		for(int x=0;x<=diff;x+=2)
		{
			//for each iteration the number is generated by adding the value of x{which is a subset of the range} to the lower bound number.
			i=lb.add(new BigInteger(x+""));
			p=new BigInteger("2");//p initialized to the lowest possible prime factor.
			q=i.subtract(p);//Initialized to i-p.

			//loop until we find a prime p and prime q
			while(!(p.isProbablePrime(100)&&q.isProbablePrime(100)))
			{
				p=p.nextProbablePrime();//next probable number for p.
				q=i.subtract(p);
			}
				//check if the current p is greater than the max p discovered until now.
				globalMax.reduce(new GoldbachVbl(i, p, q));

		}
		System.out.println(globalMax.getI()+" = "+globalMax.getP()+" + "+globalMax.getQ());//print the result to the console.
	}


	/*
	 * Method:checkisEven(number)
	 * This method checks if the number passed is even.
	 * @param: number-The BigInteger number to be tested for being even.
	 * @return:Boolean indicating if the number is even.
	 * @author:Salil Rajadhyaksha
	 * 
	 */
	private boolean checkisEven(BigInteger number) {

		if(number.mod(new BigInteger("2")).intValue()==0)
			return true;
		else
			return false;
	}

}
